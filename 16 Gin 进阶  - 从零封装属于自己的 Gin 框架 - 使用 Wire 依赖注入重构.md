# 第十六章  - 从零封装属于自己的 Gin 框架 - 使用 Wire 依赖注入重构

学习资料参考：[手把手，带你从零封装Gin框架](https://juejin.cn/post/7101966893522616356)

### 15.1 为什么要重构

由于之前项目中各个组件都是通过全局变量传递的，随着项目的推进，一大堆全局变量会混成一团，**如果一不小心在某个地方对全局变量进行修改将可能引发严重的 `panic`** ，便打算使用依赖注入重构一下。

 **`Wire` 是一个灵活的依赖注入工具，能够帮助我们在程序编译期就完成依赖注入。**



### 15.2 依赖注入与Wire简介

依赖注入是指组件在创建时，就应该获取该组件所依赖的其他关系，如下代码所示，要创建一个 `App` 实例需要 `Config` 、 `Server` 结构体:

分别展示使用与未使用依赖注入的两种方式。

```go
type App struct {
    conf *Config
    httpServer *Server
}

// 构建 Config
func InitConfig() *Config {
    return &Config{}
}

// 构建 Server
func NewHttpServer() *Server {
    return &Server{}
}

// 构建 App （内部调用依赖组件的构建函数）
func NewApp() *App {
    return &App{
        conf: InitConfig(),
        httpServer: NewHttpServer(),
    }
}

// 构建 App （需由调用者传入依赖组件）
func NewAppByDI(conf *Config, httpSrv *Server) *App {
    return &App{
        conf: conf,
        httpServer: httpSrv,
    }
}

func main() {
    // 未使用依赖注入
    app := NewApp()
  
    // 使用依赖注入
    config := InitConfig()
    server := NewHttpServer()
    app := NewAppByDI(config, server)
}
```

未使用依赖注入的情况下，调用者无法知道 `App` 内部使用了 `Config` 和 `Server` ，如果 `Config` 构建函数 `InitConfig()` 发生变化，假设需要增加一个参数，我们就需要在每个调用 `InitConfig()` 的地方修改代码。

使用依赖注入的情况下，将 `Config` 和 `Server` 的构建逻辑与构建 `App` 的逻辑分离开，即使 `Config ` 的构建函数 `InitConfig` 发生了变化，也只需要修改一处代码，但是在构建 `App` 之前，需要手动构建 `Config` 和 `Server` ，随着程序推进，这些依赖关系将越来越复杂，这时候就需要依赖注入工具 `Wire` 来帮助我们生成依赖关系。



### 15.3 依赖注入重构实践

安装工具：

```
# 导入项目
go get -u github.com/google/wire

# 安装命令
go install github.com/google/wire/cmd/wire
```

这里只简单展示一下 `wire.go` 文件，主要工作就是先为之前项目中使用的各个组件都编写 `Provider` 函数，然后在 `wire.Build()` 中传入各个 `Provider` 即可，完整代码请查看 [github.com/jassue/gin-…](https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2Fjassue%2Fgin-wire) 。

```go
package main

import (
    "github.com/google/wire"
    "github.com/jassue/gin-wire/app/compo"
    "github.com/jassue/gin-wire/app/cron"
    "github.com/jassue/gin-wire/app/data"
    "github.com/jassue/gin-wire/app/handler"
    "github.com/jassue/gin-wire/app/service"
    "github.com/jassue/gin-wire/config"
    "github.com/jassue/gin-wire/router"
    "go.uber.org/zap"
    "gopkg.in/natefinch/lumberjack.v2"
)

// wireApp init application.
func wireApp(*config.Configuration, *lumberjack.Logger, *zap.Logger) (*App, func(), error) {
    panic(wire.Build(data.ProviderSet, compo.ProviderSet, service.ProviderSet, handler.ProviderSet, router.ProviderSet, cron.ProviderSet, newHttpServer, newApp))
}
```



### 15.4 Wire 使用示例

**下面是一个 Wire 的使用示例**

假设我们要创建一个简单的应用，其中有两个依赖：`Database` 和 `UserService`。

+ `UserService` 依赖于 `Database`，而 `Database` 是由 `DBConnection` 提供的。
+ 我们通过 `wire` 来自动生成依赖注入代码。

**1.定义依赖的结构体**

```go
package main

import "fmt"

// Database 表示数据库连接
type Database struct {
	DSN string
}

// NewDatabase 创建一个新的 Database 实例
func NewDatabase() (*Database, error) {
	return &Database{DSN: "user:password@/dbname"}, nil
}

// UserService 表示用户服务
type UserService struct {
	DB *Database
}

// NewUserService 创建一个新的 UserService 实例
func NewUserService(db *Database) *UserService {
	return &UserService{DB: db}
}
```

**2.使用 `wire` 注入依赖**

接下来，我们定义一个 `wire` 提供的 `Set`，它描述了如何组合各个构造函数并自动注入依赖。

```go
package main

import "github.com/google/wire"

// Set 定义了如何为 UserService 提供所需的依赖
var Set = wire.NewSet(NewDatabase, NewUserService)
```

**3.创建一个 `main` 函数，并使用 `wire` 生成代码**

`main` 函数通过调用 `wire` 来注入依赖：

```go
package main

import "fmt"

// InjectUserService 是 wire 生成的依赖注入函数
func InjectUserService() (*UserService, error) {
	panic(wire.Build(Set)) // Wire 会根据 Set 自动生成代码
}

func main() {
	userService, err := InjectUserService()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("UserService initialized with DB:", userService.DB.DSN)
}
```

**4. 运行 `wire` 生成代码**

在终端中运行以下命令，`wire` 会自动生成一个 `wire_gen.go` 文件，它将包含依赖注入的实现代码。

```
wire
```

生成的 `wire_gen.go` 文件大致如下：

```go
// Code generated by Wire. DO NOT EDIT.

//go:generate wire

package main

import (
	"github.com/google/wire"
)

func InitializeUserService() (*UserService, error) {
	wire.Build(NewDatabase, NewUserService)
	return &UserService{}, nil
}
```

**5. 完整代码**

最终的文件结构如下

```
main.go
wire.go
wire_gen.go
```

`main.go` 的内容是：

```go
package main

import "fmt"

// InjectUserService 是 wire 生成的依赖注入函数
func InjectUserService() (*UserService, error) {
	panic(wire.Build(Set)) // Wire 会根据 Set 自动生成代码
}

func main() {
	userService, err := InjectUserService()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}

	fmt.Println("UserService initialized with DB:", userService.DB.DSN)
}

// output: UserService initialized with DB: user:password@/dbname
```

`InjectUserService` 是 `wire` 生成的函数，它会自动调用构造函数并返回一个已经注入了依赖的 `UserService` 实例。

**通过 `go-wire`，我们可以实现自动化的依赖注入，减少了手动管理依赖的复杂性，尤其适合大型项目。依赖注入可以提高代码的可测试性、可扩展性和可维护性。**